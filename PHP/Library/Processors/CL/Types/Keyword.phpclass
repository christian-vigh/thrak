<?php
/***************************************************************************************************

    NAME
	Keyword.phpclass

    DESCRIPTION
	Keyword parameter type.

    AUTHOR
     	Christian Vigh, 05/2011.

    HISTORY
    [Version : 1.0]	[Date : 2011/05/27]	[Author : CV]
     	Initial version.

   [Version : 2.0]	[Date : 2012/10/06]		[Author : CV]
	Migrated to the Thrak library version 2.

   [Version : 2.0.1]	[Date : 2015/01/08]		[Author : CV]
	. Added a newline between each constant definition in GetHelp().

   [Version : 2.0.2]	[Date : 2015/03/09]		[Author : CV]
 	. Fixed misalignment problems in help text generated by the ProcessChildTag() method.

   [Version : 2.0.3]	[Date : 2015/04/11]		[Author : CV]
	. Replaced each exception throwing with "error ( new CLException (...) )".

   [Version : 2.0.4]	[Date : 2015/05/07]		[Author : CV]
 	. Corrected a text alignment problem when displaying keyword values help.

   [Version : 2.0.5]	[Date : 2015/06/14]		[Author : CV]
	. Added the "constant" attribute, which can be used to specify a constant value that must
	  be assigned to the "value" attribute. The constant can be either a global constant or a
	  class constant.

   [Version : 2.0.6]	[Date : 2015/06/18]		[Author : CV]
	. nth correction to the GetHelp() method for alignment problems. Think I finally got it...
 
 ***************************************************************************************************/
namespace  	Thrak\Processors\CL ;

defined ( '__THRAK_SETUP__' ) or die ( "This file cannot be accessed directly." ) ;


// Used namespaces and classes
use 	Thrak\Processors\CL\CLException ;
use     Thrak\Types\StringUtilities ;
use	Thrak\Types\String\Formatting ;


/*==================================================================================================

    CLKeywordParameter class -
	Implements a keyword parameter.

  ==================================================================================================*/
class  CLKeywordParameter  extends  \Thrak\Processors\CL\CLAbstractParameter
   {
   	// Keyword entries
   	public 		$KeywordDefinitions	=  array ( ) ;
   	// 'else' option
   	private		$ElseDefinition		=  false ;
   	// Existing keyword names
   	private 	$ExistingNames		=  array ( ) ;


	/*-------------------------------------------------------------------------------------------

		Class constructor.

	 --------------------------------------------------------------------------------------------*/
	public function  __construct ( $parent, $tags, $valuetext = "keyword" )
	   {
   		$this -> Help = "Defines a keyword parameter. It can contain any number of <case>, <keyword> or <option> subtags, with the following attributes :\n\n" .
  		 		"name -\n" .
		   		"	Comma-separated list of names and aliases for this keyword.\n\n" .
		   		"value -\n" .
		   		"       Corresponding value. If this attribute is not specified, then the keyword value will be the first parameter name.\n\n" .
				"constant -\n" .
				"	Name of a global or class constant to be assigned to the value, if not specified.\n\n" . 
		   		"help -\n" .
		   		"       Help text for this keyword value.\n\n" .
				"The <else> or <case-else> subtag can be specified to allow any other kind of value." ;

		$this -> ReturnValueHelp 	=  "Returns the value associated with the supplied keyword." ;

		parent::__construct ( $parent, $tags, $valuetext ) ;
	    }


 	/*-------------------------------------------------------------------------------------------

	    GetHelp -
	    	Returns the help text for this keyword.

 	 --------------------------------------------------------------------------------------------*/
	public function  GetHelp ( )
	   {
		$help 	=  parent::GetHelp ( ) ; 

		if  ( $help )
			$help .= "\n" ;
		else
			$help = "" ;

		$help .= "\t\tAvailable keywords : \n" ;

		// Loop through keyword definitions
		foreach  ( $this -> KeywordDefinitions  as  $definition )
		   {
			// Remove leading space, leaving only one tab to the second and subsequent lines
			$help_text	=  preg_replace ( '/\n\s*/', "\n\t", ltrim ( $definition [ 'help' ] ) ) ;

			// Evaluate PHP tags
			$help_text	=  $this -> Parent -> EvaluatePhpTags ( $help_text, 'help', "\t" ) ;

			// Format the resulting text using 3 leading tabs (well, 24 spaces...)
		   	$help .= Formatting::FormatParagraph ( $help_text, null, $this -> Parent -> MaxWidth, 24 ) . "\n\n" ;
		    }

		return ( rtrim ( $help ) ) ;
	    }


 	/*-------------------------------------------------------------------------------------------

	    ProcessChildTag -
	    	Processes <option> or <keyword> tags.

 	 --------------------------------------------------------------------------------------------*/
	protected function  ProcessChildTag ( $child )
	   {
	   	// Get child and parent tagname
	   	$tag 	=  $child [ 'tag' ] ;
	   	$name 	=  $this -> GetUsageParameterName ( ) ;
		   
		// Check if they are allowed
		if  ( strcasecmp ( $tag, 'keyword' )  &&  strcasecmp ( $tag, 'option' )  &&  strcasecmp ( $tag, "constant" )  &&
		      strcasecmp ( $tag, 'case'    )  &&
		      strcasecmp ( $tag, 'else' )  &&  strcasecmp ( $tag, 'case-else' ) )
		   {
			parent::ProcessChildTag ( $child ) ;
			exit ( ) ;
   		    }

		// Get inner contents
	   	$contents 		=  trim ( $child [ 'contents' ] ) ;

		// Process the <else> special tag
		$else  	=  false ;

		if  ( ! strcasecmp ( $tag, 'else' )  ||  ! strcasecmp ( $tag, 'case-else' ) )
		   {
		   	if  ( $this -> ElseDefinition )
		   		error ( new CLException ( "The <$tag> tag can only be specified once for the '$name' parameter." ) ) ;

			$this -> ElseDefinition 	=  true ;
			$attrnames 			=  array ( null ) ;
			$attrvalue			=  null ;
			$attrconst			=  null ;
			$attrhelp			=  null ;
			$else 				=  true ;

			foreach  ( $child [ 'attributes' ]  as  $attribute )
			   {
				switch ( strtolower ( $attribute [ 'name' ] ) )
				   {
					case	'value' :
						$attrvalue =  $attribute [ 'value' ] ;
						break ;

					case	'constant' :
						$attrconst =  $attribute [ 'value' ] ;
						break ;

					case	'help' :
						$attrhelp = $attribute [ 'value' ] ;
						break ;

					default :
						error ( new CLException ( "Invalid attribute '{$attribute [ 'name' ]} for the <$tag> subtag of the '$name' parameter." ) ) ;
				    }
			    }
		    }
		else
		   {
			// Loop through attributes to get names and value
		   	$attrnames		=  null ;
		   	$attrvalue 		=  null ;
			$attrhelp		=  null ;
			$attrconst		=  null ;

			foreach  ( $child [ 'attributes' ]  as  $attribute )
			   {
				switch ( strtolower ( $attribute [ 'name' ] ) )
				   {
					case	'name' :
						$attrnames = StringUtilities::ExplodeAndTrim ( ',', $attribute [ 'value' ] ) ;

						// Check that the name was not already specified
						foreach  ( $attrnames  as  $attrname )
						   {
						   	$attrname = strtolower ( $attrname ) ;

							if  ( in_array ( $attrname, $this -> ExistingNames ) )
									error ( new CLException ( "The keyword name '$attrname' has been defined more than once for the '$name' parameter." ) ) ;

							$this -> ExistingNames [] = $attrname ;
						    }

						break ;

					case	'value' :
						$attrvalue =  $attribute [ 'value' ] ;
						break ;

					case	'constant' :
						$attrconst =  $attribute [ 'value' ] ;
						break ;

					case	'help' :
						$attrhelp = $attribute [ 'value' ] ;
						break ;

					default :
						error ( new CLException ( "Invalid attribute '{$attribute [ 'name' ]} for the <$tag> subtag of the '$name' parameter." ) ) ;
				    }
			    }
		     }

		// Check that we have the mandatory 'name=' attribute
		if  ( ! $attrnames )
			error ( new CLException ( "The 'name' attribute is required for the <$tag> subtag of the '$name' parameter." ) ) ;

		// Provide a default value for the 'value' attribute if none specified
		if  ( $attrvalue  ===  null )
		   {
			// If a constant name has been specified, check it
			if  ( $attrconst )
			   {
				preg_match ( '/( (?P<class> .*?) ::)? (?P<constant> .*)/imsx', $attrconst, $match ) ;
				$class		=  ( isset ( $match [ 'class' ] )  &&  $match [ 'class' ] ) ?  trim ( $match [ 'class' ] ) : false ;
				$constant	=  trim ( $match [ 'constant' ] ) ;
				
				if  ( $class )
				   {
					if  ( class_exists ( $class ) )
					   {
						if  ( defined ( "$class::$constant" ) )
							$attrvalue	=  constant ( "$class::$constant" ) ;
						else
							error ( new CLException ( "The '$class::$constant' constant referenced by the 'constant' attribute of the <$tag> " .
										  "subtag of the '$name' parameter does not reference a valid class constant." ) ) ;
					    }
					else
						error ( new CLException ( "The '$class' class referenced by the 'constant' attribute of the <$tag> " .
									  "subtag of the '$name' parameter does not reference a valid class." ) ) ;
				    }
				else
				   {
					if  ( defined ( $constant ) )
						$attrvalue	=  constant ( $constant ) ;
					else
						error ( new CLException ( "The '$constant' constant referenced by the 'constant' attribute of the <$tag> " .
									  "subtag of the '$name' parameter does not reference a valid constant." ) ) ;
				    }
			    }
			else
				$attrvalue =  $attrnames [0] ;
		    }

		// Build a help string
		if  ( is_array ( $attrnames ) )
			$attrlist 	=  implode ( ', ', $attrnames ) ;
		else
			$attrlist 	=  $attrnames ;

		if ( ! $contents  &&  $attrhelp  !=  null )
			$contents	=  $attrhelp ;

		if  ( $else )
		   {
			$help  =  "Other cases" ;

			if  ( $attrvalue  !==  null )
				$help .= " (value = $attrvalue)" ;

			$help .= " :\t\t\t\t$contents" ;
		    }
		else
		   {
			$help  =  $attrlist . " (value = $attrvalue) :\n" ;
			$help .=  "\t\t\t\t$contents" ;
		    }

		// Add the new entry
		if  ( ! $else )
			$this -> KeywordDefinitions [] = array ( 'names' => $attrnames, 'value' => $attrvalue, 'constant' => $attrconst, 'help' => $help ) ;
		else
			$this -> KeywordDefinitions [ '*' ] = array ( 'names' => $attrnames, 'value' => $attrvalue, 'constant' => $attrconst, 'help' => $help ) ;
	    }


 	/*-------------------------------------------------------------------------------------------

	    ProcessValue -
	    	Processes a keyword value.

 	 --------------------------------------------------------------------------------------------*/
	protected function  ProcessValue ( $pname, $pvalue )
	   {
	   	// Loop through the possible keyword values
		foreach  ( $this -> KeywordDefinitions  as  $definition )
		   {
			foreach  ( $definition [ 'names' ]  as  $name )
			   {
				if  ( ! strcasecmp ( $pvalue, $name ) )
					return ( $definition [ 'value' ] ) ;
			    }
		    }

		// If not found and an <else> tag has been specified, return the user-specified value
		if  ( array_key_exists ( '*', $this -> KeywordDefinitions ) )
			return ( $this -> KeywordDefinitions [ '*' ] ) ;
		// Otherwise throw an exception
		else
			error ( new CLException ( "Invalid keyword '$pvalue' for the '$pname' keyword." ) ) ;
	    }
    }