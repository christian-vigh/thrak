<?php
/**************************************************************************************************************

    NAME
        TiffBase.phpclass

    DESCRIPTION
        Base classes for other TIFF manipulation classes.

    AUTHOR
        Christian Vigh, 04/2017.

    REFERENCES
	- https://www.itu.int/itudoc/itu-t/com16/tiff-fx/docs/tiff6.pdf :
		Specifications of the TIFF file format version 6.
	- http://www.awaresystems.be/imaging/tiff.html :
		Where to get a list of available TIFF IFD tags.

    HISTORY
    [Version : 1.0]	[Date : 2017-04-08]     [Author : CV]
        Initial version.

    [Version : 1.0.1]	[Date : 2017-04-14]     [Author : CV]
	. Moved most of the code from TiffSplitter to TiffImage.
	. Added the static $TypeNames array, which associates a TYPE_xxx constant with its string representation.
	. Added the 'ifd-offset' and 'typename' items in each IFD entry.

    [Version : 1.0.2]	[Date : 2017-04-16]     [Author : CV]
	. Added the TiffIFD and TiffIfdEntry classes.

    [Version : 1.0.3]	[Date : 2017-05-03]     [Author : CV]
	. Set TiffPage::PageNumber to a sequential index when no PAGE_NUMBER entry is specified in a TIFF page.
	. Added the TAG_CLEAN_FAX_DATA tag.

    [Version : 1.0.4]	[Date : 2017-05-03]     [Author : CV]
	. Changed the meaning of the TiffPage::PageNumber property : sometimes an IFD does not contain a
	  PAGE_NUMBER entry, sometimes all the PAGE_NUMBER entries can be zero. The PageNumber property
	  now reflects the sequential page number, from 0 to page count - 1.
	. Added the ActualPageNumber property, which reflects the page number as mentioned in the IFD.

 **************************************************************************************************************/
namespace 	Thrak\Graphics ;

// Used namespaces and objects
use 		Thrak\System\Object ;


class  TiffException	extends  \Thrak\System\Exception {}

/*==============================================================================================================

        Custom error reporting functions.

  ==============================================================================================================*/
if  ( ! function_exists ( 'warning' ) )
   {
	function  warning ( $message )
	   {
		trigger_error ( $message, E_USER_WARNING ) ;
	    }
    }


if  ( ! function_exists ( 'error' ) )
   {
	function  error ( $message )
	   {
		if  ( is_string ( $message ) )
			trigger_error ( $message, E_USER_ERROR ) ;
		else if (  is_a ( $message, '\Exception' ) )
			throw $message ;
	    }
    }


/*==============================================================================================================

    class TiffImage -
        Base class for TiffSplitter. Contains mainly constants.

  ==============================================================================================================*/
class  TiffImage	extends  Object 
   {
	// Enable debugging here
	public static		$DEBUG		=  false ;

	// Endianness of the supplied file - given by the first two bytes
	const		LITTLE_ENDIAN				=  0x4949 ;
	const		BIG_ENDIAN				=  0x4D4D ;

	// A constant identifier, at offsets 2..3 of the TIFF file (this WORD16 depends on the endianness given by the first two bytes)
	const		TIFF_IDENTIFIER				=  42 ;

	// IFD entry size 
	const		IFD_ENTRY_SIZE				=  12 ;

	// Type of entries in the Image File Directory (IFD)
	const		TYPE_BYTE				=  1 ;		// 8-byte unsigned integer
	const		TYPE_ASCII				=  2 ;		// ASCII 8-bit byte that contains a 7-bit ASCII code; the last byte must be NUL (binary zero).
	const		TYPE_SHORT				=  3 ;		// SHORT 16-bit (2-byte) unsigned integer.
	const		TYPE_LONG				=  4 ;		// LONG 32-bit (4-byte) unsigned integer.
	const		TYPE_RATIONAL				=  5 ;		// RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator.
	const		TYPE_SBYTE				=  6 ;		// SBYTE An 8-bit signed (twos-complement) integer.
	const		TYPE_UNDEFINED				=  7 ;		// UNDEFINED An 8-bit byte that may contain anything, depending on the definition of the field.
	const		TYPE_SSHORT				=  8 ;		// SSHORT A 16-bit (2-byte) signed (twos-complement) integer.
	const		TYPE_SLONG				=  9 ;		// SLONG A 32-bit (4-byte) signed (twos-complement) integer.
	const		TYPE_SRATIONAL				=  10 ;		// SRATIONAL Two SLONG’s: the first represents the numerator of a fraction, the second the denominator.
	const		TYPE_FLOAT				=  11 ;		// FLOAT Single precision (4-byte) IEEE format.
	const		TYPE_DOUBLE				=  12 ;		// DOUBLE Double precision (8-byte) IEEE format.
	const		TYPE_IGNORED				=  255 ;	// Indicates a tag that we will ignore

	// Possible kind of values for the Value/Offset value field
	const		INLINE_ALWAYS				=  0 ;		// Data is always inlined in the Value/Offset Value field
	const		INLINE_NEVER				=  1 ;		// Data is never inlined
	const		INLINE_POSSIBLE				=  2 ;		// Data may be inlined 

	// IFD types
	const		IFD_STANDARD				=  0 ;
	const		IFD_EXIF				=  1 ;
	const		IFD_GPS_EXIF				=  2 ;
	const		IFD_INTEROPERABILITY_EXIF		=  3 ;

	// Tags that describe the data contained in the Value/Value offset field
	const		TAG_ARTIST				=  0x013B ;	// (ASCII) Creator of the image
	const		TAG_BITS_PER_SAMPLE			=  0x0102 ;	// (SHORT) Number of bits per component (4 or 8)
	const		TAG_CELL_LENGTH				=  0x0109 ;	// (SHORT) Length of the dithering or halftoning matrix used to create a dithered or halftoned bilevel file.
	const		TAG_CELL_WIDTH				=  0x0108 ;	// (SHORT) Width of the dithering or halftoning matrix used to create a dithered or halftoned bilevel file
	const		TAG_COLOR_MAP				=  0x0140 ;	// (SHORT) RGB color map (short???)
	const		TAG_CLEAN_FAX_DATA			=  0x0147 ;	// (SHORT) Used in the TIFF-F standard, indicates if 'bad' lines encountered during reception are stored in 
										// the data, or if 'bad' lines have been replaced by the receiver.
	const		TAG_COMPRESSION				=  0x0103 ;	// (SHORT) Type of compression used (1 = use as few bits as possible, 2 = CCITT FAX compression)
	const		TAG_COPYRIGHT				=  0x8298 ;	// (ASCII) Copyright information
	const		TAG_DATETIME				=  0x0132 ;	// (ASCII) Date/time of image creation
	const		TAG_DOCUMENT_NAME			=  0x010D ;	// (ASCII) The name of the document from which this image was scanned
	const		TAG_DOT_RANGE				=  0x0150 ;	// (BYTE or SHORT) The component values that correspond to a 0% dot and 100% dot
	const		TAG_EXIF_IFD				=  0x8769 ;	// (LONG) Pointer to EXIF IFD
	const		TAG_EXTRA_SAMPLES			=  0x0152 ;	// (SHORT) Extra data associated with image bits
	const		TAG_FILL_ORDER				=  0x010A ;	// (SHORT) Logical order of bits within a byte 
	const		TAG_FREE_BYTE_COUNT			=  0x0121 ;	// (LONG) For each string of contiguous unused bytes in a TIFF file, the number of bytes in the string
	const		TAG_FREE_OFFSETS			=  0x0120 ;	// (LONG) For each string of contiguous unused bytes in a TIFF file, the byte offset of the string
	const		TAG_GPS_IFD				=  0x8825 ;	// (LONG) A pointer to the Exif-related GPS Info IFD
	const		TAG_GRAY_RESPONSE_CURVE			=  0x0123 ;	// (SHORT) For grayscale data, the optical density of each possible pixel value
	const		TAG_GRAY_RESPONSE_UNIT			=  0x0122 ;	// (SHORT) The precision of the information contained in the GrayResponseCurve
	const		TAG_HALFTONE_HINTS			=  0x0141 ;	// (SHORT * 2) 
	const		TAG_HOST_COMPUTER			=  0x013C ;	// (ASCII) The computer and/or operating system in use at the time of image creation
	const		TAG_ICC_PROFILE				=  0x8773 ;	// (UNDEFINED) ICC profile data
	const		TAG_IMAGE_DESCRIPTION			=  0x010E ;	// (ASCII) A string that describes the subject of the image
	const		TAG_IMAGE_LENGTH			=  0x0101 ;	// (SHORT or LONG) Number of rows in the image
	const		TAG_IMAGE_PREDICTOR			=  0x013D ;	// (SHORT) Mathematical operator that is applied to the image data before an encoding scheme is applied
	const		TAG_IMAGE_SOURCE_DATA			=  0x935C ;	// (UNDEFINED) Used by Photoshop
	const		TAG_IMAGE_WIDTH				=  0x0100 ;	// (SHORT or LONG) Number of columns in the image
	const		TAG_INK_NAMES				=  0x014D ;	// (ASCII) List of null-separated ink names
	const		TAG_INK_SET				=  0x014C ;	// (SHORT) The set of inks used in a separated (PhotometricInterpretation=5) image
	const		TAG_INTEROPERABILITY_IFD		=  0xA005 ;	// (LONG) A pointer to the Exif-related Interoperability IFD
	const		TAG_IPTC_METADATA			=  0x83BB ;	// (UNDEFINED or BYTE) IPTC (International Press Telecommunications Council) metadata
	const		TAG_JPEG_INTERCHANGE_FORMAT		=  0x0201 ;	// (LONG) Indicates whether a JPEG interchange format bitstream is present in the TIFF file.
	const		TAG_JPEG_INTERCHANGE_FORMAT_LENGTH	=  0x0202 ;	// (LONG) Length in bytes of the JPEG interchange format bitstream.
	const		TAG_JPEG_LOSSLESS_PREDICTORS		=  0x0205 ;	// (SHORT) Points to a list of lossless predictor-selection values, one per component.
	const		TAG_JPEG_POINT_TRANSFORMS		=  0x0206 ;	// (SHORT) Points to a list of point transform values, one per component
	const		TAG_JPEG_PROC				=  0x0200 ;	// (SHORT) JPEG process used to generate compressed data
	const		TAG_JPEG_RESTART_INTERVAL		=  0x0203 ;	// (SHORT) Length of the restart interval used in the compressed image data.
	const		TAG_JPEG_Q_TABLES			=  0x0207 ;	// (LONG) Points to a list of offsets to the quantization tables, one per component
	const		TAG_JPEG_DC_TABLES			=  0x0208 ;	// (LONG) Points to a list of offsets to the DC Huffman tables or the lossless Huffman tables, one per component
	const		TAG_JPEG_AC_TABLES			=  0x0209 ;	// (LONG) Points to a list of offsets to the Huffman AC tables, one per component
	const		TAG_MAKE				=  0x010F ;	// (ASCII) The scanner manufacturer
	const		TAG_MAX_SAMPLE_VALUE			=  0x0119 ;	// (SHORT) The maximum component value used.
	const		TAG_MIN_SAMPLE_VALUE			=  0x0119 ;	// (SHORT) The minimum component value used.
	const		TAG_MODEL				=  0x0110 ;	// (ASCII) The scanner model name or number
	const		TAG_NEW_SUBFILE_TYPE			=  0x00FE ;	// (LONG) A general indication of the kind of data contained in this subfile
	const		TAG_NUMBER_OF_INKS			=  0x014E ;	// (SHORT) Number of inks
	const		TAG_ORIENTATION				=  0x0112 ;	// (SHORT) The orientation of the image with respect to the rows and columns
	const		TAG_PAGE_NAME				=  0x011D ;	// (ASCII) The name of the page from which this image was scanned
	const		TAG_PAGE_NUMBER				=  0x0129 ;	// (SHORT) The page number of the page from which this image was scanned
	const		TAG_PHOTOMETRIC_INTERPRETATION		=  0x0106 ;	// (SHORT) Indicates whether 0 is white or black (0 = white is zero, 1 = black is zero)
	const		TAG_PHOTOSHOP				=  0x8649 ;	// (BYTE) Collection of Photoshop image resource blocks
	const		TAG_PLANAR_CONFIGURATION		=  0x011C ;	// (SHORT) How the components of each pixel are stored.
	const		TAG_PRIMARY_CHROMACITIES		=  0x013F ;	// (RATIONAL) Chromaticities of the primaries of an image
	const		TAG_REFERENCE_BLACK_WHITE		=  0x0214 ;	// (RATIONAL) Did not understand this value
	const		TAG_RESOLUTION_UNIT			=  0x0128 ;	// (SHORT) Resolution (1 = no unit, 2 = inch, 3 = centimeter)
	const		TAG_ROWS_PER_STRIP			=  0x0116 ;	// (SHORT or LONG) Rows per strip 
	const		TAG_SAMPLE_FORMAT			=  0x0153 ;	// (SHORT) How to interpret each data sample in a pixel
	const		TAG_SAMPLES_PER_PIXEL			=  0x0115 ;	// (SHORT) Number of components per pixel (eg, 3 for RGB colors)
	const		TAG_SMAX_SAMPLE_VALUE			=  0x0154 ;	// (type that best matches sample data) Maximum sample value
	const		TAG_SMIN_SAMPLE_VALUE			=  0x0154 ;	// (type that best matches sample data) Minimum sample value
	const		TAG_SOFTWARE				=  0x0131 ;	// (ASCII) Name and version number of the software package(s) used to create the image
	const		TAG_STRIP_BYTE_COUNTS			=  0x0117 ;	// (SHORT or LONG) Number of bytes in each strip after compression
	const		TAG_STRIP_OFFSETS			=  0x0111 ;	// (SHORT or LONG) Byte offset of each strip
	const		TAG_SUBFILE_TYPE			=  0x00FF ;	// (SHORT) A general indication of the kind of data contained in this subfile
	const		TAG_T4_OPTIONS				=  0x0124 ;	// (LONG) Options for COMPRESSION = 3
	const		TAG_T6_OPTIONS				=  0x0125 ;	// (LONG) Options for COMPRESSION = 4
	const		TAG_TARGET_PRINTER			=  0x0151 ;	// (ASCII) Target printer name
	const		TAG_TILE_BYTE_COUNTS			=  0x0145 ;	// (SHORT or LONG) Number of compressed bytes for each tile
	const		TAG_TILE_LENGTH				=  0x0143 ;	// (SHORT or LONG) Tile length in pixels
	const		TAG_TILE_OFFSETS			=  0x0144 ;	// (LONG) Byte offsets of each tile
	const		TAG_TILE_WIDTH				=  0x0142 ;	// (SHORT or LONG) Tile width in pixels
	const		TAG_THRESHHOLDING			=  0x0107 ;	// (SHORT) Technique used to convert from gray to black&white pixels
	const		TAG_TRANSFER_FUNCTION			=  0x012D ;	// (SHORT) Transfer function for images in tabular style
	const		TAG_TRANSFER_RANGE			=  0x0156 ;	// (SHORT) Expands the range of the transfer function.
	const		TAG_WHITE_POINT				=  0x013E ;	// (RATIONAL) Chromaticity of the white point of an image
	const		TAG_X_POSITION				=  0x011E ;	// (RATIONAL) X position of the image
	const		TAG_XML_METADATA			=  0x02BC ;	// (BYTE) XML packet containing XMP metadata, such as description, title, etc.
	const		TAG_X_RESOLUTION			=  0x011A ;	// (RATIONAL) Number of pixels per resolution unit in the image width
	const		TAG_Y_POSITION				=  0x011F ;	// (RATIONAL) Y position of the image
	const		TAG_Y_RESOLUTION			=  0x011B ;	// (RATIONAL) Number of pixels per resolution unit in the image length
	const		TAG_YCC_COEFFICIENTS			=  0x0211 ;	// (RATIONAL) Transformation from RGB to Y Cb Cr data
	const		TAG_YCC_POSITIONING			=  0x0213 ;	// (SHORT) Specifies the positioning of subsampled chrominance components relative to luminance samples
	const		TAG_YCC_SUBSAMPLING			=  0x0212 ;	// (SHORT) Subsampling factors used for the chrominance components of a YCbCr image.

	// EXIF tags
	const		TAG_EXIF_EXPOSURE_TIME			=  0x829A ;	// (RATIONAL) Exposure time, in seconds
	const		TAG_EXIF_F_NUMBER			=  0x829D ;	// (RATIONAL) F number (?)
	const		TAG_EXIF_EXPOSURE_PROGRAM		=  0x8822 ;	// (SHORT) Class of the program used by the camera to set exposure when the picture is taken. 
	const		TAG_EXIF_SPECTRAL_SENSITIVITY		=  0x8824 ;	// (ASCII) Indicates the spectral sensitivity of each channel of the camera used. 
										// The tag value is an ASCII string compatible with the standard developed by the ASTM Technical committee. 
	const		TAG_EXIF_ISO_SPEED_RATINGS		=  0x8827 ;	// (SHORT) Indicates the ISO Speed and ISO Latitude of the camera or input device as specified in ISO 12232. 
	const		TAG_EXIF_OECF				=  0x8828 ;	// (UNDEFINED) Indicates the Opto-Electric Conversion Function (OECF) specified in ISO 14524. 
	const		TAG_EXIF_VERSION			=  0x9000 ;	// (UNDEFINED) The version of the supported Exif standard, as 4 ascii bytes (TODO: check if LONG or offset)
	const		TAG_EXIF_DATETIME_ORIGINAL		=  0x9003 ;	// (ASCII) The date and time when the original image data was generated.
	const		TAG_EXIF_DATETIME_DIGITIZED		=  0x9004 ;	// (ASCII) The date and time when the image was stored as digital data.
	const		TAG_EXIF_COMPONENTS_CONFIGURATION	=  0x9101 ;	// (UNDEFINED) Specific to compressed data; specifies the channels and complements PhotometricInterpretation
	const		TAG_EXIF_COMPRESSED_BITS_PER_PIXEL	=  0x9102 ;	// (RATIONAL) Specific to compressed data; states the compressed bits per pixel.
	const		TAG_EXIF_SHUTTER_SPEED_VALUE		=  0x9201 ;	// (SRATIONAL) Shutter speed
	const		TAG_EXIF_APERTURE_VALUE			=  0x9202 ;	// (RATIONAL) Lens aperture
	const		TAG_EXIF_BRIGHTNESS_VALUE		=  0x9203 ;	// (SRATIONAL) Brightness value
	const		TAG_EXIF_EXPOSURE_BIAS_VALUE		=  0x9204 ;	// (SRATIONAL) Exposure bias
	const		TAG_EXIF_MAX_APERTURE_VALUE		=  0x9205 ;	// (RATIONAL) The smallest F number of the lens.
	const		TAG_EXIF_SUBJECT_DISTANCE		=  0x9206 ;	// (RATIONAL) The distance to the subject, given in meters
	const		TAG_EXIF_METERING_MODE			=  0x9207 ;	// (SHORT) Metering mode
	const		TAG_EXIF_LIGHT_SOURCE			=  0x9208 ;	// (SHORT) Light source
	const		TAG_EXIF_FLASH				=  0x9209 ;	// (SHORT) Indicates the status of flash when the image was shot
	const		TAG_EXIF_FOCAL_LENGTH			=  0x920A ;	// (RATIONAL) The actual focal length of the lens, in mm
	const		TAG_EXIF_SUBJECT_AREA			=  0x9214 ;	// (SHORT) Indicates the location and area of the main subject in the overall scene
	const		TAG_EXIF_MAKER_NOTE			=  0x927C ;	// (UNDEFINED) Manufacturer specific information
	const		TAG_EXIF_USER_COMMENT			=  0x9286 ;	// (UNDEFINED) Keywords or comments on the image; complements ImageDescription
	const		TAG_EXIF_SUBSEC_TIME			=  0x9290 ;	// (ASCII) A tag used to record fractions of seconds for the DateTime tag
	const		TAG_EXIF_SUBSEC_TIME_ORIGINAL		=  0x9291 ;	// (ASCII) A tag used to record fractions of seconds for the DateTimeOriginal tag
	const		TAG_EXIF_SUBSEC_TIME_DIGITIZED		=  0x9292 ;	// (ASCII) A tag used to record fractions of seconds for the DateTimeDigitized tag
	const		TAG_EXIF_FLASHPIX_VERSION		=  0xA000 ;	// (UNDEFINED) The Flashpix format version supported by a FPXR file
	const		TAG_EXIF_COLOR_SPACE			=  0xA001 ;	// (SHORT) The color space information tag is always recorded as the color space specifier
	const		TAG_EXIF_PIXEL_X_DIMENSION		=  0xA002 ;	// (SHORT or LONG) Specific to compressed data; the valid width of the meaningful image
	const		TAG_EXIF_PIXEL_Y_DIMENSION		=  0xA003 ;	// (SHORT or LONG) Specific to compressed data; the valid height of the meaningful image
	const		TAG_EXIF_RELATED_SOUND_FILE		=  0xA004 ;	// (ASCII) Used to record the name of an audio file related to the image data (MSDOS 8.3 file name format)
	const		TAG_EXIF_FLASH_ENERGY			=  0xA20B ;	// (RATIONAL) Indicates the strobe energy at the time the image is captured, as measured in Beam Candle Power Seconds
	const		TAG_EXIF_SPATIAL_FREQUENCY_RESPONSE	=  0xA20C ;	// (UNDEFINED) Records the camera or input device spatial frequency table and SFR values 
	const		TAG_EXIF_FOCAL_PLANE_X_RESOLUTION	=  0xA20E ;	// (RATIONAL) Indicates the number of pixels in the image width (X) direction per FocalPlaneResolutionUnit on the camera focal plane
	const		TAG_EXIF_FOCAL_PLANE_Y_RESOLUTION	=  0xA20F ;	// (RATIONAL) Indicates the number of pixels in the image height (Y) direction per FocalPlaneResolutionUnit on the camera focal plane
	const		TAG_EXIF_FOCAL_PLANE_RESOLUTION_UNIT	=  0xA210 ;	// (SHORT) Indicates the unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
	const		TAG_EXIF_SUBJECT_LOCATION		=  0xA214 ;	// (SHORT) Indicates the location of the main subject in the scene
	const		TAG_EXIF_EXPOSURE_INDEX			=  0xA215 ;	// (RATIONAL) Indicates the exposure index selected on the camera or input device at the time the image is captured
	const		TAG_EXIF_SENSING_METHOD			=  0xA217 ;	// (SHORT) Indicates the image sensor type on the camera or input device
	const		TAG_EXIF_FILE_SOURCE			=  0xA300 ;	// (SHORT) Indicates the image source
	const		TAG_EXIF_SCENE_TYPE			=  0xA301 ;	// (UNDEFINED) Indicates the type of scene
	const		TAG_EXIF_CFA_PATTERN			=  0xA302 ;	// (UNDEFINED) Indicates the color filter array (CFA) geometric pattern of the image sensor when a one-chip color area sensor is used. 
	const		TAG_EXIF_CUSTOM_RENDERED		=  0xA401 ;	// (SHORT) Indicates the use of special processing on image data, such as rendering geared to output
	const		TAG_EXIF_EXPOSURE_MODE			=  0xA402 ;	// (SHORT) Indicates the use of special processing on image data, such as rendering geared to output
	const		TAG_EXIF_WHITE_BALANCE			=  0xA403 ;	// (SHORT) Indicates the white balance mode set when the image was shot
	const		TAG_EXIF_DIGITAL_ZOOM_RATIO		=  0xA404 ;	// (RATIONAL) Indicates the digital zoom ratio when the image was shot
	const		TAG_EXIF_FOCAL_LENGTH_IN_35mm_FILM	=  0xA405 ;	// (SHORT) Indicates the equivalent focal length assuming a 35mm film camera, in mm
	const		TAG_EXIF_SCENE_CAPTURE_TYPE		=  0xA406 ;	// (SHORT) Indicates the type of scene that was shot
	const		TAG_EXIF_GAIN_CONTROL			=  0xA407 ;	// (SHORT) Indicates the degree of overall image gain adjustment
	const		TAG_EXIF_CONTRAST			=  0xA408 ;	// (SHORT) Indicates the direction of contrast processing applied by the camera when the image was shot
	const		TAG_EXIF_SATURATION			=  0xA409 ;	// (SHORT) Indicates the direction of saturation processing applied by the camera when the image was shot
	const		TAG_EXIF_SHARPNESS			=  0xA40A ;	// (SHORT) Indicates the direction of sharpness processing applied by the camera when the image was shot
	const		TAG_EXIF_DEVICE_SETTING_DESCRIPTION	=  0xA40B ;	// (UNDEFINED) This tag indicates information on the picture-taking conditions of a particular camera model
	const		TAG_EXIF_SUBJECT_DISTANCE_RANGE		=  0xA40C ;	// (SHORT) Indicates the distance to the subject
	const		TAG_EXIF_IMAGE_UNIQUE_ID		=  0xA420 ;	// (ASCII) Indicates an identifier assigned uniquely to each image

	// GPS EXIF tags
	const		TAG_GPS_VERSION_ID			=  0x0000 ;	// (BYTE) Indicates the version of GPSInfoIFD
	const		TAG_GPS_LATITUDE_REF			=  0x0001 ;	// (ASCII) Indicates whether the latitude is north or south latitude ('S' or 'N').
	const		TAG_GPS_LATITUDE			=  0x0002 ;	// (RATIONAL) Indicates the latitude (3 rationals for degrees, minutes and seconds)
	const		TAG_GPS_LONGITUDE_REF			=  0x0003 ;	// (ASCII) Indicates whether the latitude is north or south latitude ('E' or 'W').
	const		TAG_GPS_LONGITUDE			=  0x0004 ;	// (RATIONAL) Indicates the latitude (3 rationals for degrees, minutes and seconds)
	const		TAG_GPS_ALTITUDE_REF			=  0x0005 ;	// (BYTE) Indicates the altitude used as the reference altitude
	const		TAG_GPS_ALTITUDE			=  0x0006 ;	// (RATIONAL) Indicates the altitude based on the reference in GPSAltitudeRef
	const		TAG_GPS_TIMESTAMP			=  0x0007 ;	// (RATIONAL) Indicates the time as UTC (Coordinated Universal Time)
	const		TAG_GPS_SATELLITES			=  0x0008 ;	// (ASCII) Indicates the GPS satellites used for measurements
	const		TAG_GPS_STATUS				=  0x0009 ;	// (ASCII) Indicates the status of the GPS receiver when the image is recorded
	const		TAG_GPS_MEASURE_MODE			=  0x000A ;	// (ASCII) Indicates the GPS measurement mode
	const		TAG_GPS_DOP				=  0x000B ;	// (RATIONAL) Indicates the GPS DOP (data degree of precision). 
	const		TAG_GPS_SPEED_REF			=  0x000C ;	// (ASCII) Indicates the unit used to express the GPS receiver speed of movement
	const		TAG_GPS_SPEED				=  0x000D ;	// (RATIONAL) Indicates the speed of GPS receiver movement
	const		TAG_GPS_TRACK_REF			=  0x000E ;	// (ASCII) Indicates the reference for giving the direction of GPS receiver movement
	const		TAG_GPS_TRACK				=  0x000F ;	// (RATIONAL) Indicates the direction of GPS receiver movement
	const		TAG_GPS_IMG_DIRECTION_REF		=  0x0010 ;	// (ASCII) Indicates the reference for giving the direction of the image when it is captured
	const		TAG_GPS_IMG_DIRECTION			=  0x0011 ;	// (RATIONAL) ndicates the direction of the image when it was captured
	const		TAG_GPS_MAP_DATUM			=  0x0012 ;	// (ASCII) Indicates the geodetic survey data used by the GPS receiver
	const		TAG_GPS_DEST_LATITUDE_REF		=  0x0013 ;	// (ASCII) Indicates whether the latitude of the destination point is north or south latitude
	const		TAG_GPS_DEST_LATITUDE			=  0x0014 ;	// (RATIONAL) Indicates the latitude of the destination point
	const		TAG_GPS_DEST_LONGITUDE_REF		=  0x0015 ;	// (ASCII) Indicates whether the longitude of the destination point is north or south latitude
	const		TAG_GPS_DEST_LONGITUDE			=  0x0016 ;	// (RATIONAL) Indicates the logitude of the destination point
	const		TAG_GPS_DEST_BEARING_REF		=  0x0017 ;	// (ASCII) Indicates the reference used for giving the bearing to the destination point.
	const		TAG_GPS_DEST_BEARING			=  0x0018 ;	// (RATIONAL) Indicates the logitude of the destination point
	const		TAG_GPS_DEST_DISTANCE_REF		=  0x0019 ;	// (ASCII) Indicates the unit used to express the distance to the destination point
	const		TAG_GPS_DEST_DISTANCE			=  0x001A ;	// (RATIONAL) Indicates the distance to the destination point
	const		TAG_GPS_PROCESSING_METHOD		=  0x001B ;	// (UNDEFINED) A character string recording the name of the method used for location finding
	const		TAG_GPS_AREA_INFORMATION		=  0x001C ;	// (UNDEFINED) A character string recording the name of the GPS area
	const		TAG_GPS_DATESTAMP			=  0x001D ;	// (ASCII) A character string recording date and time information relative to UTC (Coordinated Universal Time)
	const		TAG_GPS_DIFFERENTIAL			=  0x001E ;	// (SHORT) Indicates whether differential correction is applied to the GPS receiver

	// Interoperability EXIF tags
	const		TAG_INTEROP_INTEROPERABILITY_INDEX	=  0x0001 ;	// (ASCII) Indicates the identification of the Interoperability rule


	// Output format for individual pages
	const		OUTPUT_FORMAT_TIFF			=  0 ;
	//const		OUTPUT_FORMAT_PDF			=  1 ;

	// Types associated to each tag
	public static	$TagTypes			=  array
	   (
		self::IFD_STANDARD			=>  array
		   (
			self::TAG_ARTIST				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_BITS_PER_SAMPLE			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_CELL_LENGTH				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_CELL_WIDTH				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_CLEAN_FAX_DATA			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_COLOR_MAP				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_COMPRESSION				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_COPYRIGHT				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_DATETIME				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_DOCUMENT_NAME				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_DOT_RANGE				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_EXIF_IFD				=>  array ( 'type' => self::TYPE_IGNORED	),
			self::TAG_EXTRA_SAMPLES				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_FILL_ORDER				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_FREE_BYTE_COUNT			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_FREE_OFFSETS				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_GPS_IFD				=>  array ( 'type' => self::TYPE_IGNORED	),
			self::TAG_GRAY_RESPONSE_CURVE			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_GRAY_RESPONSE_UNIT			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_HALFTONE_HINTS			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_HOST_COMPUTER				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_ICC_PROFILE				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_IMAGE_DESCRIPTION			=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_IMAGE_LENGTH				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_IMAGE_PREDICTOR			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_IMAGE_SOURCE_DATA			=>  array ( 'type' => self::TYPE_UNDEFINED	),
			self::TAG_IMAGE_WIDTH				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_INK_NAMES				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_INK_SET				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_INTEROPERABILITY_IFD			=>  array ( 'type' => self::TYPE_IGNORED	),
			self::TAG_IPTC_METADATA				=>  array ( 'type' => self::TYPE_IGNORED	),
			self::TAG_JPEG_INTERCHANGE_FORMAT		=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_JPEG_INTERCHANGE_FORMAT_LENGTH	=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_JPEG_LOSSLESS_PREDICTORS		=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_JPEG_POINT_TRANSFORMS			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_JPEG_PROC				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_JPEG_RESTART_INTERVAL			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_JPEG_Q_TABLES				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_JPEG_AC_TABLES			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_JPEG_DC_TABLES			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_MAKE					=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_MAX_SAMPLE_VALUE			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_MIN_SAMPLE_VALUE			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_MODEL					=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_NEW_SUBFILE_TYPE			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_NUMBER_OF_INKS			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_ORIENTATION				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_PAGE_NAME				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_PAGE_NUMBER				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_PHOTOMETRIC_INTERPRETATION		=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_PHOTOSHOP				=>  array ( 'type' => self::TYPE_BYTE		),
			self::TAG_PLANAR_CONFIGURATION			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_PRIMARY_CHROMACITIES			=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_REFERENCE_BLACK_WHITE			=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_RESOLUTION_UNIT			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_ROWS_PER_STRIP			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_SAMPLE_FORMAT				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_SAMPLES_PER_PIXEL			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_SMAX_SAMPLE_VALUE			=>  array ( 'type' => self::TYPE_IGNORED	),
			self::TAG_SMIN_SAMPLE_VALUE			=>  array ( 'type' => self::TYPE_IGNORED	),
			self::TAG_SOFTWARE				=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_STRIP_BYTE_COUNTS			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_STRIP_OFFSETS				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_SUBFILE_TYPE				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_T4_OPTIONS				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_T6_OPTIONS				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_TARGET_PRINTER			=>  array ( 'type' => self::TYPE_ASCII		),
			self::TAG_TILE_BYTE_COUNTS			=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_TILE_LENGTH				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_TILE_OFFSETS				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_TILE_WIDTH				=>  array ( 'type' => self::TYPE_LONG		),
			self::TAG_THRESHHOLDING				=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_TRANSFER_FUNCTION			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_TRANSFER_RANGE			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_WHITE_POINT				=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_X_POSITION				=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_X_RESOLUTION				=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_XML_METADATA				=>  array ( 'type' => self::TYPE_BYTE		),
			self::TAG_Y_POSITION				=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_Y_RESOLUTION				=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_YCC_COEFFICIENTS			=>  array ( 'type' => self::TYPE_RATIONAL	),
			self::TAG_YCC_POSITIONING			=>  array ( 'type' => self::TYPE_SHORT		),
			self::TAG_YCC_SUBSAMPLING			=>  array ( 'type' => self::TYPE_SHORT		)
		    ) 
	    ) ;	

	// Association between type constants and type names
	public static   $TypeNames		=  array ( ) ;

	// Input filename (false if instantiated from string contents)
	public		$Filename		=  false ;
	// Endianness (either LITTLE_ENDIAN or BIG_ENDIAN)
	public		$Endianness ;

	// Tiff data
	public		$TiffData ;
	// TIFF page information, sorted by actual page number defined in the file
	protected	$Pages			=  array ( ) ;

	// Indicates whether static information has been initialized 
	static private	$StaticInitialized	=  false ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    Constructor -
		Associates tag constants in the $TagTypes static array with their string representation.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( )
	   {
		if  ( ! self::$StaticInitialized )
		   {
			$me		=  new  \ReflectionClass ( $this ) ;
			$constants	=  $me -> getConstants ( ) ;

			foreach  ( $constants  as  $name => $value )
			   {
				if  ( ! strncmp ( $name, 'TAG_', 4 ) )
				   {
					foreach  ( self::$TagTypes  as  $ifd_type => &$types )
					   {
						if  ( isset ( $types [ $value ] ) )
							$types [ $value ] [ 'name' ]	=  $name ;
					    }
				    }
				else if ( ! strncmp ( $name, 'TYPE_', 5 ) )
					self::$TypeNames [ $value ]	=  $name ;
			    }

			self::$StaticInitialized	=  true ;
		    }

		parent::__construct ( ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    GetPageInstance -
		Returns an instance of a TiffPage.
		The fact that such a method exists is to allow derived classes to implement a specialized version of a
		TiffPage, as this is the case for TiffSplitter.
			
	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  GetPageInstance ( $parent, $ifd_data )
	   {
		return ( new TiffPage ( $parent, $ifd_data ) ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        Load - Loads a TIFF file
	
	    PROTOTYPE
	        $splitter	=  TiffSplitter::Load ( $filename, $buffer_size = 8192, $cache_size = 512 ) ;
	
	    DESCRIPTION
	        Loads a TIFF file.
	
	    PARAMETERS
	        $filename (string) -
	                Path to the TIFF file to be loaded.

		$buffer_size (integer) -
			TIFF data is read from the TIFF file by chunks of $buffer_size buffers.
			The default buffer size is 8192 (8Kb). On most systems, larger buffer sizes do not improve
			in a significant way the I/O performances.

		$cache_size (integer) -
			Since some multipage TIFF files could exceed the size of the available memory, a primitive
			cache system has been implemented. This parameter specifies the maximum number of buffers that
			should be kept at once into memory.
	
	    RETURN VALUE
	        Returns a TiffSplitter object.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public static function  Load ( $filename, $buffer_size = 8192, $cache_size = 512 )
	   {
		// Check that the file exists
		if  ( ! file_exists ( $filename ) )
			error ( new TiffException ( "File \"$filename\" does not exist." ) ) ;

		// Initialize the TiffSplitter object, using the TiffFile class to access the data
		$tiff			=  new  TiffSplitter ( ) ;

		$tiff -> Filename	=  $filename ;
		$tiff -> TiffData	=  new  TiffFile ( $filename, $buffer_size, $cache_size ) ;
		$tiff -> Endianness	=  $tiff -> TiffData -> Endianness ;
		
		// Parse the TIFF file contents (only the ImageFile Directory - IFD - will be retrieved for the moment)
		$tiff -> __parse ( ) ;

		// All done, return
		return ( $tiff ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        LoadFromString - Loads TIFF data from a string.
	
	    PROTOTYPE
	        $splitter	=  TiffSplitter::LoadFromString ( $tiff_data ) ;
	
	    DESCRIPTION
	        Loads TIFF data directly from memory.
	
	    PARAMETERS
	        $tiff_data (string) -
	                String containing TIFF data.
	
	    RETURN VALUE
	        Returns a TiffSplitter object.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	public static function  LoadFromString ( $tiff_data )
	   {
		$tiff			=  new  TiffSplitter ( ) ;

		$tiff -> TiffData	=  new  TiffString ( $tiff_data ) ;
		$tiff -> Endianness	=  $tiff -> TiffData -> Endianness ;
		
		$tiff -> __parse ( ) ;

		return ( $tiff ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Interfaces implementations.

	 *-------------------------------------------------------------------------------------------------------------*/

	// Countable interface
	public function  Count ( )
	   { return ( count ( $this -> Pages ) ) ; }


	// IteratorAggregate interface
	public function  getIterator ( )
	   { return ( new \ArrayIterator ( $this -> Pages ) ) ; }


	// ArrayAccess interface
	public function  offsetExists ( $offset )
	   { return ( $offset  <=  0  &&  $offset  <  count ( $this -> Pages ) ) ; }


	public function  offsetGet ( $offset )
	   { return ( $this -> Pages [ $offset ] ) ; }


	public function  offsetSet ( $offset, $value )
	   { error ( new \Thrak\System\UnsupportedOperationException ( ) ) ; }


	public function  offsetUnset ( $offset )
	   { error ( new \Thrak\System\UnsupportedOperationException ( ) ) ; }


	/*--------------------------------------------------------------------------------------------------------------
	
		Internal functions.

	 *-------------------------------------------------------------------------------------------------------------*/

	// __parse -
	//	Retrieves the Image File Directories from the supplied TIFF contents.
	//	The offset of the first IFD is given by a WORD32 value located at offset 4 in the TIFF contents, after
	//	the WORD16 identifying the endianness at offset 0, and the magic WORD16 value 42 at offset 2.
	//	For more information, read the specification, pages 13-14 and so...
	private function  __parse ( )
	   {
		// Get the offset in the file of the first IFD
		$ifd_offset	=  $this -> TiffData -> GetWord32 ( 4 ) ;

		// Loop through all the IFDs defined in this file
		$current_ifd	=  0 ;

		do
		   {
			$new_ifd_offset  =  $this -> GetIFD ( $ifd_offset, $ifd_data ) ;
			$current_ifd ++ ;

			if  ( self::$DEBUG )
			   {
				echo ( "IFD #$current_ifd at offset 0x" . sprintf ( "%08X", $ifd_offset ) . ", entry count : " . count ( $ifd_data ) . "\n" ) ;
				$current_entry	=  0 ;

				foreach  ( $ifd_data  as  $ifd_entry )
				   {
					echo ( "\tEntry #" . ( $current_entry ) . " :\n" ) ;
					echo ( "\t\tTag         : " . sprintf ( "0x%04X", $ifd_entry -> Tag ) . " ({$ifd_entry -> Tagname})\n" ) ;
					echo ( "\t\tType        : {$ifd_entry -> Type}\n" ) ;
					echo ( "\t\tCount       : {$ifd_entry -> Count}\n" ) ;
					echo ( "\t\tValue       : " . sprintf ( "0x%08X", $ifd_entry -> Value ) . "\n" ) ;
					echo ( "\t\tActual size : " . sprintf ( "0x%08X", $ifd_entry -> ActualSize ) . "\n" ) ;
					echo ( "\t\tSupported   : " . ( ( $ifd_entry -> Supported ) ? "yes" : "no" ) . "\n" ) ;

					$current_entry ++ ;
				    }
			    }

			// Create a new Page object corresponding to the IFD data found
			$page			=  new TiffSplitterPage ( $this, $ifd_data ) ;

			$this -> Pages []	=  $page ;

			$ifd_offset		=  $new_ifd_offset ;

		    }  while  ( $ifd_offset ) ;

		// Assign a sequential page number to each page
		for  ( $page_index = 0, $page_count = count ( $this -> Pages ) ; $page_index  <  $page_count ; $page_index ++ )
			$this -> Pages [ $page_index ]	-> PageNumber	=  $page_index ;
	    }


	// GetIFD -
	//	Retrieve an IFD pointing at the specified offset.
	public function  GetIFD ( $ifd_offset, &$ifd_data )
	   {
		$ifd_data	=  new TiffIFD ( $this ) ;

		// Retrieve the number of 12-bytes entries in this IFD
		$ifd_count	=  $this -> TiffData -> GetWord16 ( $ifd_offset ) ;

		// Make the current offset point to the first IFD entry
		$ifd_offset	+=  2 ;

		// Retrieve all the fields from the 12 bytes IFD entry
		for  ( $i = 0 ; $i  <  $ifd_count ; $i ++, $ifd_offset += self::IFD_ENTRY_SIZE )
		   {
			// Tag (TiffImage::TAG_* constants) + entry type (TiffImage::TYPE_* constants)
			$w	=  $this -> TiffData -> GetWord16 ( $ifd_offset, 2 ) ;

			// Entry count + value or offset
			$dw	=  $this -> TiffData -> GetWord32 ( $ifd_offset + 4, 2 ) ;

			$entry_tag	=  $w  [1] ;
			$entry_type	=  $w  [2] ;
			$entry_count	=  $dw [1] ;
			$entry_value	=  $dw [2] ;

			// Add this new entry to the current IFD
			$ifd_entry		=  new TiffIFDEntry ( $this, $entry_tag, $entry_type, $entry_count, $entry_value, $ifd_offset ) ;
			$ifd_data []		=  $ifd_entry ;
		    }

		// An IFD is always followed by a pointer to the next IFD
		$ifd_offset	=  $this -> TiffData -> GetWord32 ( $ifd_offset	 ) ;

		// All done, return
		return ( $ifd_offset ) ;
	    }
    }


/*==============================================================================================================

    class TiffPage -
        Implements an IFD (ie, all the information needed to build a page of a TIFF file).

  ==============================================================================================================*/
class  TiffPage			extends  Object
   {
	// Page number 
	public		$PageNumber		=  false ;		// Sequential page number assigned by the TiffImage class
	public		$ActualPageNumber	=  false ;		// Actual page number, as mentioned in the IFD (if any)
	// Page dimensions
	public		$PageWidth		=  0,
			$PageHeight		=  0 ;
	// Parent TiffSplitter object
	public		$Parent ;
	// Image file directory for this page
	public		$IFD ;
	// EXIF IFD
	public		$EXIF_IFD ; 
	// GPS IFD
	public		$GPS_IFD ;
	// Interoperability IFD 
	public		$Interoperability_IFD ;


	/*--------------------------------------------------------------------------------------------------------------

	    Constructor - 
		Instantiates a TIFF page and retrieves the page number, if any.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( $parent, $ifd_data )
	   {
		$this -> Parent		=  $parent ;
		$this -> IFD		=  $ifd_data ;

		if  ( ( $entry = $ifd_data -> GetTagById ( TiffImage::TAG_PAGE_NUMBER ) )  !==  false )
			$this -> ActualPageNumber	=  $entry -> Value & 0xFFFF ;

		if  ( ( $entry = $ifd_data -> GetTagById ( TiffImage::TAG_IMAGE_WIDTH ) )  !==  false )
			$this -> PageWidth		=  $entry -> Value ;

		if  ( ( $entry = $ifd_data -> GetTagById ( TiffImage::TAG_IMAGE_LENGTH ) )  !==  false )
			$this -> PageHeight		=  $entry -> Value ;
	    }
    }


/*==============================================================================================================

    class TiffIFD -
        Implements an image file directory.

  ==============================================================================================================*/
class	TiffIFD			extends		Object 
				implements	\ArrayAccess, \Countable, \IteratorAggregate
   {
	// Image File Directory entries
	protected		$IFD			=  array ( ) ;
	protected		$IFDCount		=  0 ;
	protected		$SupportedIFDCount	=  0 ;

	// Entries indexed by their tag constant
	protected		$IFDTagIndexes		=  array ( ) ;
	// Entries indexed by their human-readable tag constant
	protected		$IFDTagnameIndexes	=  array ( ) ;
	// Parent TIFF image
	protected		$ParentImage ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    Constructor -
		Creates an IFD structure.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( $parent_image )
	   {
		$this -> ParentImage	=  $parent_image ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    GetRealCount -
		Returns the number of supported IFD entries.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  GetRealCount ( )
	   { return ( $this -> SupportedIFDCount ) ; }


	/*--------------------------------------------------------------------------------------------------------------
	
	    GetTagById -
		Returns a TiffIFDEntry based on its tag name (one of the TiffImage::TAG_* constants).
		Returns false in no corresponding entry exists.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  GetTagById ( $tagid )
	   {
		if  ( isset ( $this -> IFDTagIndexes [ $tagid ] ) )
			return ( $this -> IFD [ $this -> IFDTagIndexes [ $tagid ] ] ) ;
		else
			return ( false ) ;
	    }

	/*--------------------------------------------------------------------------------------------------------------
	
		Interfaces implementations.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  count ( )
	   { return ( $this -> IFDCount ) ; }


	public function  getIterator ( )
	   { return ( new \ArrayIterator ( $this -> IFD ) ) ; }


	public function  offsetExists ( $offset )
	   { return ( $offset  >=  0  &&  $offset  <  $this -> IFDCount ) ; }


	public function  offsetGet ( $offset )
	   { return ( $this -> IFD [ $offset ] ) ; }
	

	public function  offsetSet ( $offset, $ifd_entry )
	   { 
		if  ( $offset  ===  null )
		   {
			$this -> IFD []			=  $ifd_entry ;
			$index				=  $this -> IFDCount ;
			$this -> IFDCount ++ ;
		    }
		else
		   {
			$this -> IFD [ $offset ]	=  $ifd_entry ;
			$index				=  $offset ;
			$this -> IFDCount		=  count ( $this -> IFD ) ;
		    }

		if  ( $ifd_entry -> Supported )
			$this -> SupportedIFDCount ++ ;

		$this -> IFDTagIndexes     [ $ifd_entry -> Tag ]	=  $index ;
		$this -> IFDTagnameIndexes [ $ifd_entry -> Tagname ]	=  $index ;
	    }
	

	public function  offsetUnset ( $offset )
	   { 
		if  ( isset ( $this -> IFD [ $offset ] ) )
		   {
			$ifd_entry	=  $this -> IFD [ $offset ] ;

			unset ( $this -> IFDTagIndexes     [ $ifd_entry -> Tag     ] ) ;
			unset ( $this -> IFDTagnameIndexes [ $ifd_entry -> Tagname ] ) ;

			$this -> IFDCount -- ;

			if  ( $ifd_entry -> Supported )
				$this -> SupportedIFDCount -- ;

			unset ( $this -> IFD [ $offset ] ) ;
		    }
	    }
    }


/*==============================================================================================================

    class TiffIFDEntry -
        Implements an image file directory entry.

  ==============================================================================================================*/
class	TiffIFDEntry		extends  Object
   {
	// IFD data
	public			$Tag ;					// Tag id (one of the TiffImage::TAG_* constants)
	public			$Tagname ;				// Human-readable tag name
	public			$Type ;					// Entry type (one of the TiffImage::TYPE_* constants)
	public			$Typename ;				// Human-readable type name
	public			$Count ;				// Value count
	public			$Value ;				// Value data : either a DWORD or an offset pointing to the actual value data
	public			$Offset ;				// Offset of this IFD entry in the TIFF file
	public			$IsOffset ;				// True if $Value represents an offset within the TIFF file
	public			$ActualSize ;				// Actual data size (without padding)
	public			$Supported		=  true ;	// Indicates whether the current version of TiffImage supports this tag

	// Properties not to be put in everybody's hands
	protected		$NeedsPadding		=  false ;	// For binary/ascii values, indicates whether a NUL byte should be added for aligning
									// the data on a word16 boundary
	protected		$__UnderlyingValue	=  false ;	// Real data contents, if $Value is actually an offset

	// Parent TiffImage object
	protected		$ParentImage ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    Constructor -
		Creates an IFD entry.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( $parent_image, $tag, $type, $count, $value, $offset = 0, $ifd_type = TiffImage::IFD_STANDARD )
	   {
		$this -> ParentImage	=  $parent_image ;

		// Get the display name of the tag (for debugging purposes)
		if  ( isset ( TiffImage::$TagTypes [ $ifd_type ] [ $tag ] ) )
			$tagname	=  TiffImage::$TagTypes [ $ifd_type ] [ $tag ] [ 'name' ] ;
		else
			$tagname	=  "*** UNDEFINED ***" ;

		// Get the display name of the type
		if  ( isset ( TiffImage::$TypeNames [ $type ] ) )
			$typename	=  TiffImage::$TypeNames [ $type ] ;
		else	
			$typename	=  "*** UNDEFINED ***" ;

		// Initialize properties based on the supplied data
		$this -> Tag		=  $tag ;
		$this -> Tagname	=  $tagname ;
		$this -> Type		=  $type ;
		$this -> Typename	=  $typename ;
		$this -> Count		=  $count ;
		$this -> Value		=  $value ;
		$this -> Offset		=  $offset ;

		if  ( isset ( TiffImage::$TagTypes [ $ifd_type ] [ $tag ] )  &&  TiffImage::$TagTypes [ $ifd_type ] [ $tag ] [ 'type' ]  ===  TiffImage::TYPE_IGNORED )
			$this -> Supported	=  false ;

		// Determine if the IDF entry value is a value or an offset
		switch ( $this -> Type )
		   {
			// ASCII type : always terminated by a NUL character
			case	TiffImage::TYPE_ASCII :
				$this -> IsOffset	=  ( $this -> Count + 1  >  4 ) ;
				$this -> NeedsPadding	=  ( ( $this -> Count % 2 )  !==  0 ) ;
				$this -> ActualSize	=  $this -> Count ;
				break ;

			// Other binary types : the value is always an offset
			case	TiffImage::TYPE_BYTE :
			case	TiffImage::TYPE_SBYTE :
			case	TiffImage::TYPE_UNDEFINED :
				$this -> IsOffset	=  ( $this -> Count  >  4 ) ;
				$this -> NeedsPadding	=  ( ( $this -> Count % 2 )  !==  0 ) ;
				$this -> ActualSize	=  $this -> Count ;
				break ;

			// Up to two SHORTS can be stored in the value field of the IFD ; above this count, the value field is an offset
			case	TiffImage::TYPE_SHORT :
			case	TiffImage::TYPE_SSHORT :
				$this -> IsOffset	=  ( $this -> Count  >  2 ) ;
				$this -> ActualSize	=  $this -> Count * 2 ;
				break ;

			// One long can be stored in the value field of the IFD ; above 1, it will be an offset
			case	TiffImage::TYPE_LONG :
			case	TiffImage::TYPE_SLONG :
			case	TiffImage::TYPE_FLOAT :
				$this -> IsOffset	=  ( $this -> Count  >  1 ) ;
				$this -> ActualSize	=  $this -> Count * 4 ;
				break ;

			// Rationals and doubles are 64-bit values (2 DWORD32) ; so the value field of the IFD is always an offset
			case	TiffImage::TYPE_RATIONAL :
			case	TiffImage::TYPE_SRATIONAL :
			case	TiffImage::TYPE_DOUBLE :
				$this -> IsOffset	=  true ;
				$this -> ActualSize	=  $this -> Count * 8 ;
				break ;

			default :
				warning ( "Unimplemented type {$this -> Type}." ) ;
		    }
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    __get -
		Magic function used to retrieve the UnderlyingValue property, which holds the actual data when the 
		$Value property actually specifies an offset in the TIFF file.
		The actual data is loaded only on demand.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __get ( $member )
	   {
		if  ( $member  ===  'UnderlyingValue' )
		   {
			if  ( $this -> IsOffset )
			   {
				if  ( $this -> __UnderlyingValue  ===  false )
					$this -> GetUnderlyingValue ( ) ;

				return ( $this -> __UnderlyingValue ) ;
			    }
			else
				return ( $this -> Value ) ;
		    }
		else
			return ( $this -> $member ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    GetUnderlyingValue -
		Retrieve the actual data of an IFD entry whose value field is a pointer.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  GetUnderlyingValue ( )
	   {
		$data		=  $this -> ParentImage -> TiffData -> GetRawBytes ( $this -> Value, $this -> ActualSize ) ;

		if  ( $this -> NeedsPadding )
			$data	.=  "\0" ;

		$this -> __UnderlyingValue	=  $data ;
	    }
    }


/*==============================================================================================================

    class TiffData -
        A general abstract class to access bytes, words and dwords in TIFF data.

  ==============================================================================================================*/
abstract class  TiffData	extends  Object
    {
	// Underlying filename ; set to false if the data comes from a string
	public		$Filename			=  false ;

	// Either TiffImage::BIG_ENDIAN (MSB first) or LITTLE_ENDIAN (LSB first)
	public		$Endianness ;
	// Since we use the pack()/unpack() functions, we have to use the proper coding format for WORD16 and WORD32
	protected	$PackFormat16,
			$PackFormat32 ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    Constructor -
		Ensures that the supplied TIFF data starts with a word specifying the endianness of the file, followed
		by the WORD16 value 42.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( )
	   {
		$first_word			=  $this -> GetByte ( 0, 2 ) ;
		$endianness			=  ( $first_word [1]  <<  8 )  |  $first_word [2] ; 

		switch ( $endianness )
		   {
			case	TiffImage::LITTLE_ENDIAN :
				$this -> PackFormat16		=  'v' ;
				$this -> PackFormat32		=  'V' ;
				break ;

			case	TiffImage::BIG_ENDIAN :
				$this -> PackFormat16		=  'n' ;
				$this -> PackFormat32		=  'N' ;
				break ;

			default :
				$this -> InvalidTiffData ( ) ;
		    }

		$this -> Endianness	=  $endianness ;

		$tiff_id		=  $this -> GetWord16 ( 2 ) ;

		if  ( $tiff_id   !==  TiffImage::TIFF_IDENTIFIER )
			$this -> InvalidTiffData ( ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        GetByte - Returns one or more bytes from the TIFF data
	
	    PROTOTYPE
	        $result		=  $tiff_data -> GetByte ( $offset, $count = 1 ) ;
	
	    DESCRIPTION
	        Returns one or more bytes from the TIFF data, starting at the specified offset.
	
	    PARAMETERS
	        $offset (integer) -
	                Start offset.

		$count (integer) -
			Number of bytes to be retrieved.
	
	    RETURN VALUE
	        Returns a single byte value if the $count parameter is 1. If greater, returns a 1-based array of bytes.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	abstract public function	GetByte		( $offset, $count = 1 ) ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        GetWord16 - Returns one or more WORD16 values from the TIFF data
	
	    PROTOTYPE
	        $result		=  $tiff_data -> GetWord16 ( $offset, $count = 1 ) ;
	
	    DESCRIPTION
	        Returns one or more WORD16 values from the TIFF data, starting at the specified offset.
	
	    PARAMETERS
	        $offset (integer) -
	                Start offset.

		$count (integer) -
			Number of bytes to be retrieved.
	
	    RETURN VALUE
	        Returns a single WORD16 value if the $count parameter is 1. If greater, returns a 1-based array of 
		WORD16, in host order.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	abstract public function	GetWord16	( $offset, $count = 1 ) ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        GetWord32 - Returns one or more WORD32 values from the TIFF data
	
	    PROTOTYPE
	        $result		=  $tiff_data -> GetWord32 ( $offset, $count = 1 ) ;
	
	    DESCRIPTION
	        Returns one or more WORD32 values from the TIFF data, starting at the specified offset.
	
	    PARAMETERS
	        $offset (integer) -
	                Start offset.

		$count (integer) -
			Number of bytes to be retrieved.
	
	    RETURN VALUE
	        Returns a single WORD32 value if the $count parameter is 1. If greater, returns a 1-based array of 
		WORD32, in host order.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	abstract public function	GetWord32	( $offset, $count = 1 ) ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    NAME
	        GetRawBytes - Returns one or more bytes from the TIFF data as a string.
	
	    PROTOTYPE
	        $result		=  $tiff_data -> GetRawBytes ( $offset, $count = 1 ) ;
	
	    DESCRIPTION
	        Returns one or more bytes from the TIFF data, starting at the specified offset.
	
	    PARAMETERS
	        $offset (integer) -
	                Start offset.

		$count (integer) -
			Number of bytes to be retrieved.
	
	    RETURN VALUE
	        Returns a string of bytes.
	
	 *-------------------------------------------------------------------------------------------------------------*/
	abstract public function	GetRawBytes		( $offset, $count = 1 ) ;


	/*--------------------------------------------------------------------------------------------------------------
	
		General utility functions.

	 *-------------------------------------------------------------------------------------------------------------*/

	// Unpack32, Unpack16 -
	//	Unpacks raw data according to the destination byte order.
	public function  Unpack32 ( $data )
	   {
		return ( unpack ( $this -> PackFormat32 . '*', $data ) ) ;
	    }


	public function  Unpack16 ( $data )
	   {
		return ( unpack ( $this -> PackFormat16 . '*', $data ) ) ;
	    }


	// Pack32, Pack16 -
	//	Packs raw data according to the destination byte order.
	public function  Pack32 ( $data )
	   {
		return ( pack ( $this -> PackFormat32 . '*', $data ) ) ;
	    }


	public function  Pack16 ( $data )
	   {
		return ( pack ( $this -> PackFormat16 . '*', $data ) ) ;
	    }


	// ToWord16, ToWord32 -
	//	Converts a set of word16/32 values to the destination format. 
	//	Argument list is infinite and can contain arrays.
	public function  ToWord16 ( )
	   {
		$argv	=  func_get_args ( ) ;

		return ( $this -> __to_word ( $argv, $this -> PackFormat16 ) ) ;
	    }


	public function  ToWord32 ( )
	   {
		$argv	=  func_get_args ( ) ;

		return ( $this -> __to_word ( $argv, $this -> PackFormat32 ) ) ;
	    }


	private function  __to_word ( $argv, $format ) 
	   {
		$argc		=  count ( $argv ) ;

		if  ( $argc  ===  1  &&  ! is_array ( $argv [0] ) )
			$result		=  pack ( $format, $argv [0] ) ;
		else
		   {
			$new_argv	=  array ( '' ) ;
			$count		=  0 ;

			foreach  ( $argv  as  $arg )
			   {
				if  ( ! is_array ( $arg ) )
				   {
					$new_argv []	=  $arg ;
					$count ++ ;
				    }
				else
				   {
					$new_argv	 =  array_merge ( $new_argv, $arg ) ;
					$count		+=  count ( $arg ) ;
				    }
			    }

			$new_argv [0]	=  "$format$count" ;
			$result		=  call_user_func_array ( 'pack', $new_argv ) ;
		    }

		return ( $result ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Other functions to be implemented by derived classes.

	 *-------------------------------------------------------------------------------------------------------------*/

	// Close function
	public function  Close ( )
	   {}

	// Error function
	abstract protected function	InvalidTiffData ( ) ;
     }


/*==============================================================================================================

    class TiffString -
        A class to access TIFF data specified as a string.

  ==============================================================================================================*/
class  TiffString	extends  TiffData 
   {
	protected	$TiffData ;


	/*--------------------------------------------------------------------------------------------------------------
	
	    Constructor -
		Does nothing much more than calling the parent constructor, which will check the consistency of the 
		supplied data.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( $tiff_data )
	   {
		$this -> TiffData	=  $tiff_data ;

		parent::__construct ( ) ;
	    }


 	/*--------------------------------------------------------------------------------------------------------------
	
		Data retrieval functions.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  GetByte ( $offset, $count = 1 )
	   {
		$data		=  substr ( $this -> TiffData, $offset, $count ) ;
		$result		=  unpack ( 'C' . $count, $data ) ;

		if  ( $count  ===  1 ) 
			return ( $result [1] ) ;
		else
			return ( $result ) ;
	    }


	public function  GetRawBytes ( $offset, $count = 1 )
	   {
		$data		=  substr ( $this -> TiffData, $offset, $count ) ;

		return ( $data ) ;
	    }


	public function  GetWord16 ( $offset, $count = 1 )
	   {
		$byte_count	=  $count * 2 ;
		$data		=  substr ( $this -> TiffData, $offset, $byte_count ) ;
		$result		=  unpack ( $this -> PackFormat16 . $count, $data ) ;

		if  ( $count  ===  1 )
			return ( $result [1] ) ;
		else
			return ( $result ) ;
	    }


	public function  GetWord32 ( $offset, $count = 1 )
	   {
		$byte_count	=  $count * 4 ;
		$data		=  substr ( $this -> TiffData, $offset, $byte_count ) ;
		$result		=  unpack ( $this -> PackFormat32 . $count, $data ) ;

		if  ( $count  ===  1 )
			return ( $result [1] ) ;
		else
			return ( $result ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Error function.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  InvalidTiffData ( )
	   {
		error ( new TiffException ( "The supplied string does not contain valid TIFF data." ) ) ;
	    }
   }


/*==============================================================================================================

    class TiffFile -
        A class to access TIFF data residing in a file. The class provides a caching mechanisme to avoid
	unnecessary disk accesses.

  ==============================================================================================================*/
class  TiffFile		extends  TiffData
   {
	// File resource
	private		$fp ;

	// Size of a buffer in the cache
	private		$BufferSize ;
	// Max number of entries in the cache
	private		$MaxCacheSize ;
	// Associative array of cached buffers - array keys are the start offset of the buffer, and array values
	// are the buffer contents itself
	private		$Cache				=  array ( ) ;
	// Association between a sequential buffer index and its associated file offset
	private		$CacheIndexes			=  array ( ) ;
	// Actual cache size ; may not exceed $MaxCacheSize
	private		$CacheSize			=  0 ;
	// When the cache is full and a new buffer needs to be added, this property will give the index of the oldest
	// entry (buffer) loaded so far
	private		$NextOldestCacheEntry		=  -1 ;

	// Some statistics about cache hits/misses
	public		$CacheHits			=  0,
			$CacheMisses			=  0 ;


	/*--------------------------------------------------------------------------------------------------------------
	    
	    Constructor -
		Load the first buffer then call the parent constructor to check the validity of the supplied filename's
		contents.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __construct ( $filename, $buffer_size, $cache_size )
	   {
		if  ( ! ( $this -> fp = fopen ( $filename, 'r' ) ) )
			error ( new TiffException ( "Unable to open file \"$filename\"." ) ) ;

		$this -> Filename		=  $filename ;
		$this -> BufferSize		=  $buffer_size ;
		$this -> MaxCacheSize		=  $cache_size ;

		$this -> Cache [0]		=  $this -> __read_block ( 0 ) ;
		$this -> CacheIndexes []	=  0 ;
		$this -> CacheSize ++ ;

		parent::__construct ( ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
	    Destructor -
		Closes the underlying opened file.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  __destruct ( )
	   {
		$this -> Close ( ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Data retrieval functions.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  GetByte ( $offset, $count = 1 )
	   {
		$this -> __ensure_in_cache ( $offset, $offset + $count - 1 ) ;

		$data		=  $this -> __get_bytes ( $offset, $count ) ;
		$result		=  unpack ( 'C' . $count, $data ) ;

		if  ( $count  ===  1 ) 
			return ( $result [1] ) ;
		else
			return ( $result ) ;
	    }


	public function  GetRawBytes ( $offset, $count = 1 )
	   {
		$this -> __ensure_in_cache ( $offset, $offset + $count - 1 ) ;

		$data		=  $this -> __get_bytes ( $offset, $count ) ;

		return ( $data ) ;
	    }


	public function  GetWord16 ( $offset, $count = 1 )
	   {
		$byte_count	=  $count * 2 ;
		$this -> __ensure_in_cache ( $offset, $offset + $byte_count - 1 ) ;

		$data		=  $this -> __get_bytes ( $offset, $byte_count ) ;
		$result		=  unpack ( $this -> PackFormat16 . $count, $data ) ;

		if  ( $count  ===  1 )
			return ( $result [1] ) ;
		else
			return ( $result ) ;
	    }


	public function  GetWord32 ( $offset, $count = 1 )
	   {
		$byte_count	=  $count * 4 ;
		$this -> __ensure_in_cache ( $offset, $offset + $byte_count - 1 ) ;

		$data		=  $this -> __get_bytes ( $offset, $byte_count ) ;
		$result		=  unpack ( $this -> PackFormat32 . $count, $data ) ;

		if  ( $count  ===  1 )
			return ( $result [1] ) ;
		else
			return ( $result ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Close function.

	 *-------------------------------------------------------------------------------------------------------------*/
	public function  Close ( )
	   {
		if  ( $this -> fp )
			fclose ( $this -> fp ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Error function.

	 *-------------------------------------------------------------------------------------------------------------*/
	protected function  InvalidTiffData ( )
	   {
		error ( new TiffException ( "File \"{$this -> Filename}\" is not a valid TIFF file." ) ) ;
	    }


	/*--------------------------------------------------------------------------------------------------------------
	
		Support functions.

	 *-------------------------------------------------------------------------------------------------------------*/

	// __get_bytes -
	//	Effectively returns the specified number of bytes starting at the specified file offset.
	private function  __get_bytes ( $offset, $count )
	   {
		$start_block_offset		=  ( ( integer ) ( $offset / $this -> BufferSize ) ) * $this -> BufferSize ;
		$in_block_offset		=  $offset - $start_block_offset ;

		if  ( $in_block_offset + $count  <  $this -> BufferSize )
			return ( substr ( $this -> Cache [ $start_block_offset ], $in_block_offset, $count ) ) ;

		$remaining_bytes	 =  $this -> BufferSize - $in_block_offset ;
		$data			 =  substr ( $this -> Cache [ $start_block_offset ], $in_block_offset, $remaining_bytes ) ;
		$count			-=  $remaining_bytes ;

		while  ( $count  >  0 )
		   {
			$start_block_offset	+=  $this -> BufferSize ;
			$remaining_bytes	 =  ( $count  >  $this -> BufferSize ) ?  $this -> BufferSize : $count ;
			$data			.=  substr ( $this -> Cache [ $start_block_offset ], 0, $remaining_bytes ) ;
			$count			-=  $remaining_bytes ;
		    }

		return ( $data ) ;
	    }


	// __read_block -
	//	Effectively reads a block of size BufferSize from the underlying file.
	private function  __read_block ( $offset )
	   {
		fseek ( $this -> fp, $offset, SEEK_SET ) ;
		$data	=  fread ( $this -> fp, $this -> BufferSize ) ;

		return ( $data ) ;
	    }


	// __ensure_in_cache -
	//	Ensures that offsets from $start to $end are present in the cache.
	private function  __ensure_in_cache ( $start, $end )
	   {
		// Make sure that the request data length will fit in the cache
		if  ( $end - $start + 1  >  $this -> MaxCacheSize * $this -> BufferSize )
			error ( new TiffException ( "Requested data is too big to fit in the cache (0x" . sprintf ( "%08X", $start ) . "..0x" . sprintf ( "%08X", $end ) . ")." ) ) ;

		// Get the offset of the buffer containing $start
		$offset1	=  ( ( integer ) ( $start / $this -> BufferSize ) ) * $this -> BufferSize ;

		// If not present, load it
		if  ( ! isset ( $this -> Cache [ $offset1 ] ) )
		   {
			$this -> __load_block_in_cache ( $offset1 ) ;
			$this -> CacheMisses ++ ;
		    }
		else
			$this -> CacheHits ++ ;

		// Now get the offset of the buffer containing $end
		$offset2	=  ( ( integer ) ( $end   / $this -> BufferSize ) ) * $this -> BufferSize ;

		// Compute the number of buffers needed to hold that data
		$block_count	=  ( integer ) ( ( $offset2 - $offset1 ) / $this -> BufferSize ) ;

		// Then ensure that every block is present in the cache
		for  ( $i = 0, $offset = $offset1 + $this -> BufferSize; $i  <  $block_count ; $i ++, $offset += $this -> BufferSize )
		   {
			if  ( ! isset ( $this -> Cache [ $offset ] ) )
			   {
				$this -> __load_block_in_cache ( $offset ) ;
				$this -> CacheMisses ++ ;
			    }
			else
				$this -> CacheHits ++ ;
		    }
	    }


	// __load_block_in_cache -
	//	Loads a new block in the cache, replacing the oldest entry if the cache is full
	private function  __load_block_in_cache ( $offset )
	   {
		$data	=  $this -> __read_block ( $offset ) ;

		if  ( $this -> CacheSize  <  $this -> MaxCacheSize )
		   {
			$this -> Cache [ $offset ]	=  $data ;
			$this -> CacheIndexes []	=  $offset ;
			$this -> CacheSize ++ ;
		    }
		else
		   {
			$this -> NextOldestCacheEntry ++ ;

			if   ( $this -> NextOldestCacheEntry  >=  $this -> MaxCacheSize )
				$this -> NextOldestCacheEntry	=  0 ;

			$offset_to_replace						=  $this -> CacheIndexes [ $this -> NextOldestCacheEntry ] ;
			$this -> Cache [ $offset_to_replace ]				=  $data ;
			$this -> CacheIndexes [ $this -> NextOldestCacheEntry ]		=  $offset ;
		    }
	    }
    }



